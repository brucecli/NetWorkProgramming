<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nginx 中 upstream 机制的负载均衡</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h2 id="负载均衡">负载均衡</h2>

<p>upstream 机制使得 Nginx 以反向代理的形式运行，因此 Nginx 接收客户端的请求，并根据客户端的请求，Nginx 选择合适后端服务器来处理该请求。但是若存在多台后端服务器时，Nginx 是根据怎样的策略来决定哪个后端服务器负责处理请求？这就涉及到后端服务器的负载均衡问题。 <br>
Nginx 的负载均衡策略可以划分为两大类：内置策略 和 扩展策略。内置策略包含 加权轮询 和 IP hash，在默认情况下这两种策略会编译进 Nginx 内核，只需在 Nginx 配置中指明参数即可。扩展策略有第三方模块策略：fair、URL hash、consistent hash等，默认不编译进 Nginx 内核。本文只讲解 加权轮询 和 IP_hash 策略。</p>



<h2 id="加权轮询">加权轮询</h2>

<p>加权轮询策略是先计算每个后端服务器的权重，然后选择权重最高的后端服务器来处理请求。</p>



<h3 id="相关结构体">相关结构体</h3>

<p><strong>ngx_http_upstream_peer_t 结构体</strong></p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">/* 负载均衡的类型 */</span>
    ngx_http_upstream_init_pt        init_upstream;
    <span class="hljs-comment">/* 负载均衡类型的初始化函数 */</span>
    ngx_http_upstream_init_peer_pt   init;
    <span class="hljs-comment">/* 指向 ngx_http_upstream_rr_peers_t 结构体 */</span>
    <span class="hljs-keyword">void</span>                            *data;
} ngx_http_upstream_peer_t;</code></pre>

<p><strong>ngx_http_upstream_server_t 结构体</strong></p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">/* 服务器结构体 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">/* 指向存储 IP 地址的数组，因为同一个域名可能会有多个 IP 地址 */</span>
    ngx_addr_t                      *addrs;
    <span class="hljs-comment">/* IP 地址数组中元素个数 */</span>
    ngx_uint_t                       naddrs;
    <span class="hljs-comment">/* 权重 */</span>
    ngx_uint_t                       weight;
    <span class="hljs-comment">/* 最大失败次数 */</span>
    ngx_uint_t                       max_fails;
    <span class="hljs-comment">/* 失败时间阈值 */</span>
    time_t                           fail_timeout;

    <span class="hljs-comment">/* 标志位，若为 1，表示不参与策略选择 */</span>
    <span class="hljs-keyword">unsigned</span>                         down:<span class="hljs-number">1</span>;
    <span class="hljs-comment">/* 标志位，若为 1，表示为备用服务器 */</span>
    <span class="hljs-keyword">unsigned</span>                         backup:<span class="hljs-number">1</span>;
} ngx_http_upstream_server_t;</code></pre>

<p><strong>ngx_http_upstream_rr_peer_t 结构体</strong></p>



<pre class="prettyprint"><code class=" hljs cs">typedef <span class="hljs-keyword">struct</span> {
    <span class="hljs-comment">/* 后端服务器 IP 地址 */</span>
    <span class="hljs-keyword">struct</span> sockaddr                *sockaddr;
    <span class="hljs-comment">/* 后端服务器 IP 地址的长度 */</span>
    socklen_t                       socklen;
    <span class="hljs-comment">/* 后端服务器的名称 */</span>
    ngx_str_t                       name;

    <span class="hljs-comment">/* 后端服务器当前的权重 */</span>
    ngx_int_t                       current_weight;
    <span class="hljs-comment">/* 后端服务器有效权重 */</span>
    ngx_int_t                       effective_weight;
    <span class="hljs-comment">/* 配置项所指定的权重 */</span>
    ngx_int_t                       weight;

    <span class="hljs-comment">/* 已经失败的次数 */</span>
    ngx_uint_t                      fails;
    <span class="hljs-comment">/* 访问时间 */</span>
    time_t                          accessed;
    time_t                          <span class="hljs-keyword">checked</span>;

    <span class="hljs-comment">/* 最大失败次数 */</span>
    ngx_uint_t                      max_fails;
    <span class="hljs-comment">/* 失败时间阈值 */</span>
    time_t                          fail_timeout;

    <span class="hljs-comment">/* 后端服务器是否参与策略，若为1，表示不参与 */</span>
    ngx_uint_t                      down;          <span class="hljs-comment">/* unsigned  down:1; */</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> (NGX_HTTP_SSL)</span>
    ngx_ssl_session_t              *ssl_session;   <span class="hljs-comment">/* local to a process */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
} ngx_http_upstream_rr_peer_t;</code></pre>

<p><strong>ngx_http_upstream_rr_peers_t 结构体</strong></p>



<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> ngx_http_upstream_rr_peers_s  ngx_http_upstream_rr_peers_t;

<span class="hljs-keyword">struct</span> ngx_http_upstream_rr_peers_s {
    <span class="hljs-comment">/* 竞选队列中后端服务器的数量 */</span>
    ngx_uint_t                      number;

 <span class="hljs-comment">/* ngx_mutex_t                    *mutex; */</span>

    <span class="hljs-comment">/* 所有后端服务器总的权重 */</span>
    ngx_uint_t                      total_weight;

    <span class="hljs-comment">/* 标志位，若为 1，表示后端服务器仅有一台，此时不需要选择策略 */</span>
    <span class="hljs-keyword">unsigned</span>                        single:<span class="hljs-number">1</span>;
    <span class="hljs-comment">/* 标志位，若为 1，表示所有后端服务器总的权重等于服务器的数量 */</span>
    <span class="hljs-keyword">unsigned</span>                        weighted:<span class="hljs-number">1</span>;

    ngx_str_t                      *name;

    <span class="hljs-comment">/* 后端服务器的链表 */</span>
    ngx_http_upstream_rr_peers_t   *next;

    <span class="hljs-comment">/* 特定的后端服务器 */</span>
    ngx_http_upstream_rr_peer_t     peer[<span class="hljs-number">1</span>];
};</code></pre>

<p><strong>ngx_http_upstream_rr_peer_data_t 结构体</strong></p>



<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-title">typedef</span> struct {
    ngx_http_upstream_rr_peers_t   *peers;
    ngx_uint_t                      current;
    uintptr_t                      *tried;
    uintptr_t                       <span class="hljs-typedef"><span class="hljs-keyword">data</span>;</span>
} ngx_http_upstream_rr_peer_data_t;</code></pre>



<h3 id="加权轮询策略的启动">加权轮询策略的启动</h3>

<p>在 Nginx 启动过程中，在解析完 http 配置块之后，会调用各个 http 模块对应的初始函数。对于 upstream 机制的 ngx_http_upstream_module 模块来说，对应的 main 配置初始函数是ngx_http_upstream_init_main_conf() 如下所示：</p>



<pre class="prettyprint"><code class=" hljs coffeescript"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; umcf-&gt;upstreams.nelts; i++) {  

    init = uscfp[i]<span class="hljs-function">-&gt;</span>peer.init_upstream ? 
        uscfp[i]<span class="hljs-function">-&gt;</span>peer.<span class="hljs-attribute">init_upstream</span>:                                  ngx_http_upstream_init_round_robin;  

    <span class="hljs-keyword">if</span> (init(cf, uscfp[i]) != NGX_OK) {  
            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;  
    }  
}  </code></pre>

<p>在 ngx_http_upstream_module 模块中，如果用户没有做任何策略选择，那么执行默认采用加权轮询策略初始函数为ngx_http_upstream_init_round_robin。否则的话执行的是uscfp[i]-&gt;peer.init_upstream指针函数。</p>

<p>当接收到来自客户端的请求时，Nginx 会调用 ngx_http_upstream_init_request 初始化请求的过程中，调用 uscf-&gt;peer.init(r, uscf)，对于 upstream 机制的加权轮询策略来说该方法就是 ngx_http_upstream_init_round_robin_peer，该方法完成请求初始化工作。</p>



<pre class="prettyprint"><code class=" hljs r">static void  
ngx_http_upstream_init_request(ngx_http_request_t *r)  
{  
<span class="hljs-keyword">...</span>  
<span class="hljs-keyword">if</span> (uscf-&gt;peer.init(r, uscf) != NGX_OK) {  
        ngx_http_upstream_finalize_request(r, u,  
                                           NGX_HTTP_INTERNAL_SERVER_ERROR);  
        <span class="hljs-keyword">return</span>;  
    }  

    ngx_http_upstream_connect(r, u);  
}  </code></pre>

<p>完成客户端请求的初始化工作之后，会选择一个后端服务器来处理该请求，选择后端服务器由函数 ngx_http_upstream_get_round_robin_peer 实现。该函数在 ngx_event_connect_peer 中被调用。</p>



<pre class="prettyprint"><code class=" hljs r">ngx_int_t  
ngx_event_connect_peer(ngx_peer_connection_t *pc)  
{  
<span class="hljs-keyword">...</span>  
/* 调用 ngx_http_upstream_get_round_robin_peer  */
   rc = pc-&gt;get(pc, pc-&gt;data);  
   <span class="hljs-keyword">if</span> (rc != NGX_OK) {  
       <span class="hljs-keyword">return</span> rc;  
   }  

  s = ngx_socket(pc-&gt;sockaddr-&gt;sa_family, SOCK_STREAM, <span class="hljs-number">0</span>);  
<span class="hljs-keyword">...</span>  
}  </code></pre>

<p>当已经选择一台后端服务器来处理请求时，接下来就会测试该后端服务器的连接情况，测试连接由函数 ngx_http_upstream_test_connect 实现，在函数 ngx_http_upstream_send_request 中被调用。</p>



<pre class="prettyprint"><code class=" hljs r">static void  
ngx_http_upstream_send_request(ngx_http_request_t *r, ngx_http_upstream_t *u)  
{  
<span class="hljs-keyword">...</span>  
    <span class="hljs-keyword">if</span> (!u-&gt;request_sent &amp;&amp; ngx_http_upstream_test_connect(c) != NGX_OK) {  
        /* 测试连接失败 */ 
        ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);  
        <span class="hljs-keyword">return</span>;  
    }  
<span class="hljs-keyword">...</span>  
}  </code></pre>

<p>若连接测试失败，会由函数 ngx_http_upstream_next 发起再次测试，若测试成功，则处理完请求之后，会调用 ngx_http_upstream_free_round_robin_peer 释放后端服务器。</p>



<h3 id="加权轮询工作流程">加权轮询工作流程</h3>

<p>加权轮询策略的基本工作过程是：初始化负载均衡服务器列表，初始化后端服务器，选择合适后端服务器处理请求，释放后端服务器。</p>



<h4 id="初始化服务器列表">初始化服务器列表</h4>

<p>初始化服务器列表由函数 ngx_http_upstream_init_round_robin 实现，该函数的执行流程如下所示：</p>

<ul>
<li>第一种情况：若 upstream 机制配置项中配置了服务器： <br>
<ul><li>初始化非备用服务器列表，并将其挂载到 us-&gt;peer.data 中；</li>
<li>初始化备用服务器列表，并将其挂载到  peers-&gt;next 中；</li></ul></li>
<li>第二种情况：采用默认的方式 proxy_pass 配置后端服务器地址； <br>
<ul><li>初始化非备用服务器列表，并将其挂载到 us-&gt;peer.data 中；</li></ul></li>
</ul>

<p>该方法执行完成之后得到的结构如下图所示：</p>

<p><img src="http://img.blog.csdn.net/20150206170214273" alt="后端服务器列表初始化" title=""></p>



<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-comment">/* 初始化服务器负载均衡列表 */</span>
ngx_int_t
ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
    ngx_http_upstream_srv_conf_t *us)
{
    ngx_url_t                      u;
    ngx_uint_t                     i, j, n, w;
    ngx_http_upstream_server_t    *<span class="hljs-keyword">server</span>;
    ngx_http_upstream_rr_peers_t  *peers, *backup;

    <span class="hljs-comment">/* 设置 ngx_http_upstream_peer_t 结构体中 init 的回调方法 */</span>
    us-&gt;peer.init = ngx_http_upstream_init_round_robin_peer;

    <span class="hljs-comment">/* 第一种情况：若 upstream 机制中有配置后端服务器 */</span>
    <span class="hljs-keyword">if</span> (us-&gt;servers) {
        <span class="hljs-comment">/* ngx_http_upstream_srv_conf_t us 结构体成员 servers 是一个指向服务器数组 ngx_array_t 的指针，*/</span>
        <span class="hljs-keyword">server</span> = us-&gt;servers-&gt;elts;

        n = <span class="hljs-number">0</span>;
        w = <span class="hljs-number">0</span>;
        <span class="hljs-comment">/* 在这里说明下：一个域名可能会对应多个 IP 地址，upstream 机制中把一个 IP 地址看作一个后端服务器 */</span>

        <span class="hljs-comment">/* 遍历服务器数组中所有后端服务器，统计非备用后端服务器的 IP 地址总个数(即非备用后端服务器总的个数) 和 总权重 */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; us-&gt;servers-&gt;nelts; i++) {
            <span class="hljs-comment">/* 若当前服务器是备用服务器，则 continue 跳过以下检查，继续检查下一个服务器 */</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">server</span>[i].backup) {ngx_http_upstream_peer_t
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-comment">/* 统计所有非备用后端服务器 IP 地址总的个数(即非备用后端服务器总的个数) */</span>
            n += <span class="hljs-keyword">server</span>[i].naddrs;
            <span class="hljs-comment">/* 统计所有非备用后端服务器总的权重 */</span>
            w += <span class="hljs-keyword">server</span>[i].naddrs * <span class="hljs-keyword">server</span>[i].weight;
        }

        <span class="hljs-comment">/* 若 upstream 机制中配置项指令没有设置后端服务器，则出错返回 */</span>
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
            ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, <span class="hljs-number">0</span>,
                          <span class="hljs-string">"no servers in upstream \"%V\" in %s:%ui"</span>,
                          &amp;us-&gt;host, us-&gt;file_name, us-&gt;line);
            <span class="hljs-keyword">return</span> NGX_ERROR;
        }

        <span class="hljs-comment">/* 值得注意的是：备用后端服务器列表 和 非备用后端服务器列表 是分开挂载的，因此需要分开设置 */</span>
        <span class="hljs-comment">/* 为非备用后端服务器分配内存空间 */</span>
        peers = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_upstream_rr_peers_t)
                              + sizeof(ngx_http_upstream_rr_peer_t) * (n - <span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (peers == NULL) {
            <span class="hljs-keyword">return</span> NGX_ERROR;
        }

        <span class="hljs-comment">/* 初始化非备用后端服务器列表 ngx_http_upstream_rr_peers_t 结构体 */</span>
        peers-&gt;single = (n == <span class="hljs-number">1</span>);<span class="hljs-comment">/* 表示只有一个非备用后端服务器 */</span>
        peers-&gt;number = n;<span class="hljs-comment">/* 非备用后端服务器总的个数 */</span>
        peers-&gt;weighted = (w != n);<span class="hljs-comment">/* 设置默认权重为 1 或 0 */</span>
        peers-&gt;total_weight = w;<span class="hljs-comment">/* 设置非备用后端服务器总的权重 */</span>
        peers-&gt;name = &amp;us-&gt;host;<span class="hljs-comment">/* 非备用后端服务器名称 */</span>

        n = <span class="hljs-number">0</span>;

        <span class="hljs-comment">/* 遍历服务器数组中所有后端服务器，初始化非备用后端服务器 */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; us-&gt;servers-&gt;nelts; i++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">server</span>[i].backup) {<span class="hljs-comment">/* 若为备用服务器则 continue 跳过 */</span>
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-comment">/* 以下关于 ngx_http_upstream_rr_peer_t 结构体中三个权重值的说明 */</span>
            <span class="hljs-comment">/*
             * effective_weight 相当于质量(来源于配置文件配置项的 weight)，current_weight 相当于重量。
             * 前者反应本质，一般是不变的。current_weight 是运行时的动态权值，它的变化基于 effective_weight。
             * 但是 effective_weight 在其对应的 peer 服务异常时，会被调低，
             * 当服务恢复正常时，effective_weight 会逐渐恢复到实际值（配置项的weight）;
             */</span>

            <span class="hljs-comment">/* 遍历非备用后端服务器所对应 IP 地址数组中的所有 IP 地址(即一个后端服务器域名可能会对应多个 IP 地址) */</span>
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">server</span>[i].naddrs; j++) {
                <span class="hljs-comment">/* 为每个非备用后端服务器初始化 */</span>
                peers-&gt;peer[n].sockaddr = <span class="hljs-keyword">server</span>[i].addrs[j].sockaddr;<span class="hljs-comment">/* 设置非备用后端服务器 IP 地址 */</span>
                peers-&gt;peer[n].socklen = <span class="hljs-keyword">server</span>[i].addrs[j].socklen;<span class="hljs-comment">/* 设置非备用后端服务器 IP 地址长度 */</span>
                peers-&gt;peer[n].name = <span class="hljs-keyword">server</span>[i].addrs[j].name;<span class="hljs-comment">/* 设置非备用后端服务器域名 */</span>
                peers-&gt;peer[n].weight = <span class="hljs-keyword">server</span>[i].weight;<span class="hljs-comment">/* 设置非备用后端服务器配置项权重 */</span>
                peers-&gt;peer[n].effective_weight = <span class="hljs-keyword">server</span>[i].weight;<span class="hljs-comment">/* 设置非备用后端服务器有效权重 */</span>
                peers-&gt;peer[n].current_weight = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 设置非备用后端服务器当前权重 */</span>
                peers-&gt;peer[n].max_fails = <span class="hljs-keyword">server</span>[i].max_fails;<span class="hljs-comment">/* 设置非备用后端服务器最大失败次数 */</span>
                peers-&gt;peer[n].fail_timeout = <span class="hljs-keyword">server</span>[i].fail_timeout;<span class="hljs-comment">/* 设置非备用后端服务器失败时间阈值 */</span>
                peers-&gt;peer[n].down = <span class="hljs-keyword">server</span>[i].down;<span class="hljs-comment">/* 设置非备用后端服务器 down 标志位，若该标志位为 1，则不参与策略 */</span>
                n++;
            }
        }

        <span class="hljs-comment">/*
         * 将非备用服务器列表挂载到 ngx_http_upstream_srv_conf_t 结构体成员结构体
         * ngx_http_upstream_peer_t peer 的成员 data 中；
         */</span>
        us-&gt;peer.data = peers;

        <span class="hljs-comment">/* backup servers */</span>

        n = <span class="hljs-number">0</span>;
        w = <span class="hljs-number">0</span>;

         <span class="hljs-comment">/* 遍历服务器数组中所有后端服务器，统计备用后端服务器的 IP 地址总个数(即备用后端服务器总的个数) 和 总权重 */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; us-&gt;servers-&gt;nelts; i++) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">server</span>[i].backup) {
                <span class="hljs-keyword">continue</span>;
            }

            n += <span class="hljs-keyword">server</span>[i].naddrs;<span class="hljs-comment">/* 统计所有备用后端服务器的 IP 地址总的个数 */</span>
            w += <span class="hljs-keyword">server</span>[i].naddrs * <span class="hljs-keyword">server</span>[i].weight;<span class="hljs-comment">/* 统计所有备用后端服务器总的权重 */</span>
        }

        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {<span class="hljs-comment">/* 若没有备用后端服务器，则直接返回 */</span>
            <span class="hljs-keyword">return</span> NGX_OK;
        }

        <span class="hljs-comment">/* 分配备用服务器列表的内存空间 */</span>
        backup = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_upstream_rr_peers_t)
                              + sizeof(ngx_http_upstream_rr_peer_t) * (n - <span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (backup == NULL) {
            <span class="hljs-keyword">return</span> NGX_ERROR;
        }

        peers-&gt;single = <span class="hljs-number">0</span>;
        <span class="hljs-comment">/* 初始化备用后端服务器列表 ngx_http_upstream_rr_peers_t 结构体 */</span>
        backup-&gt;single = <span class="hljs-number">0</span>;
        backup-&gt;number = n;
        backup-&gt;weighted = (w != n);
        backup-&gt;total_weight = w;
        backup-&gt;name = &amp;us-&gt;host;

        n = <span class="hljs-number">0</span>;

        <span class="hljs-comment">/* 遍历服务器数组中所有后端服务器，初始化备用后端服务器 */</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; us-&gt;servers-&gt;nelts; i++) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">server</span>[i].backup) {<span class="hljs-comment">/* 若是非备用后端服务器，则 continue 跳过当前后端服务器，检查下一个后端服务器 */</span>
                <span class="hljs-keyword">continue</span>;
            }

            <span class="hljs-comment">/* 遍历备用后端服务器所对应 IP 地址数组中的所有 IP 地址(即一个后端服务器域名可能会对应多个 IP 地址) */</span>
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">server</span>[i].naddrs; j++) {
                backup-&gt;peer[n].sockaddr = <span class="hljs-keyword">server</span>[i].addrs[j].sockaddr;<span class="hljs-comment">/* 设置备用后端服务器 IP 地址 */</span>
                backup-&gt;peer[n].socklen = <span class="hljs-keyword">server</span>[i].addrs[j].socklen;<span class="hljs-comment">/* 设置备用后端服务器 IP 地址长度 */</span>
                backup-&gt;peer[n].name = <span class="hljs-keyword">server</span>[i].addrs[j].name;<span class="hljs-comment">/* 设置备用后端服务器域名 */</span>
                backup-&gt;peer[n].weight = <span class="hljs-keyword">server</span>[i].weight;<span class="hljs-comment">/* 设置备用后端服务器配置项权重 */</span>
                backup-&gt;peer[n].effective_weight = <span class="hljs-keyword">server</span>[i].weight;<span class="hljs-comment">/* 设置备用后端服务器有效权重 */</span>
                backup-&gt;peer[n].current_weight = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 设置备用后端服务器当前权重 */</span>
                backup-&gt;peer[n].max_fails = <span class="hljs-keyword">server</span>[i].max_fails;<span class="hljs-comment">/* 设置备用后端服务器最大失败次数 */</span>
                backup-&gt;peer[n].fail_timeout = <span class="hljs-keyword">server</span>[i].fail_timeout;<span class="hljs-comment">/* 设置备用后端服务器失败时间阈值 */</span>
                backup-&gt;peer[n].down = <span class="hljs-keyword">server</span>[i].down;<span class="hljs-comment">/* 设置备用后端服务器 down 标志位，若该标志位为 1，则不参与策略 */</span>
                n++;
            }
        }

        <span class="hljs-comment">/*
         * 将备用服务器列表挂载到 ngx_http_upstream_rr_peers_t 结构体中
         * 的成员 next 中；
         */</span>
        peers-&gt;next = backup;

        <span class="hljs-comment">/* 第一种情况到此返回 */</span>
        <span class="hljs-keyword">return</span> NGX_OK;
    }


     <span class="hljs-comment">/* 第二种情况：若 upstream 机制中没有直接配置后端服务器，则采用默认的方式 proxy_pass 配置后端服务器地址 */</span>
    <span class="hljs-comment">/* an upstream implicitly defined by proxy_pass, etc. */</span>

    <span class="hljs-comment">/* 若端口号为 0，则出错返回 */</span>
    <span class="hljs-keyword">if</span> (us-&gt;port == <span class="hljs-number">0</span>) {
        ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, <span class="hljs-number">0</span>,
                      <span class="hljs-string">"no port in upstream \"%V\" in %s:%ui"</span>,
                      &amp;us-&gt;host, us-&gt;file_name, us-&gt;line);
        <span class="hljs-keyword">return</span> NGX_ERROR;
    }

    <span class="hljs-comment">/* 初始化 ngx_url_t 结构体所有成员为 0 */</span>
    ngx_memzero(&amp;u, sizeof(ngx_url_t));

    u.host = us-&gt;host;
    u.port = us-&gt;port;

    <span class="hljs-comment">/* 解析 IP 地址 */</span>
    <span class="hljs-keyword">if</span> (ngx_inet_resolve_host(cf-&gt;pool, &amp;u) != NGX_OK) {
        <span class="hljs-keyword">if</span> (u.err) {
            ngx_log_error(NGX_LOG_EMERG, cf-&gt;log, <span class="hljs-number">0</span>,
                          <span class="hljs-string">"%s in upstream \"%V\" in %s:%ui"</span>,
                          u.err, &amp;us-&gt;host, us-&gt;file_name, us-&gt;line);
        }

        <span class="hljs-keyword">return</span> NGX_ERROR;
    }

    n = u.naddrs;

    <span class="hljs-comment">/* 分配非备用后端服务器列表的内存空间 */</span>
    peers = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_upstream_rr_peers_t)
                              + sizeof(ngx_http_upstream_rr_peer_t) * (n - <span class="hljs-number">1</span>));
    <span class="hljs-keyword">if</span> (peers == NULL) {
        <span class="hljs-keyword">return</span> NGX_ERROR;
    }

    <span class="hljs-comment">/* 初始化非备用后端服务器列表 */</span>
    peers-&gt;single = (n == <span class="hljs-number">1</span>);
    peers-&gt;number = n;
    peers-&gt;weighted = <span class="hljs-number">0</span>;
    peers-&gt;total_weight = n;
    peers-&gt;name = &amp;us-&gt;host;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; u.naddrs; i++) {
        peers-&gt;peer[i].sockaddr = u.addrs[i].sockaddr;
        peers-&gt;peer[i].socklen = u.addrs[i].socklen;
        peers-&gt;peer[i].name = u.addrs[i].name;
        peers-&gt;peer[i].weight = <span class="hljs-number">1</span>;
        peers-&gt;peer[i].effective_weight = <span class="hljs-number">1</span>;
        peers-&gt;peer[i].current_weight = <span class="hljs-number">0</span>;
        peers-&gt;peer[i].max_fails = <span class="hljs-number">1</span>;
        peers-&gt;peer[i].fail_timeout = <span class="hljs-number">10</span>;
    }

    <span class="hljs-comment">/* 挂载非备用后端服务器列表 */</span>
    us-&gt;peer.data = peers;

    <span class="hljs-comment">/* implicitly defined upstream has no backup servers */</span>

    <span class="hljs-keyword">return</span> NGX_OK;
}</code></pre>



<h4 id="选择合适的后端服务器">选择合适的后端服务器</h4>

<p>在选择合适的后端服务器处理客户请求时，首先需要初始化后端服务器，然后根据后端服务器的权重，选择权重最高的后端服务器来处理请求。</p>



<h5 id="初始化后端服务器">初始化后端服务器</h5>

<p>上面的初始化负载服务器列表的全局初始化工作完成之后，当客户端发起请求时，Nginx 会选择一个合适的后端服务器来处理该请求。在本轮选择后端服务器之前，Nginx 会对后端服务器进行初始化工作，该工作由函数 ngx_http_upstream_init_round_robin_peer 实现。</p>

<p>ngx_http_upstream_init_round_robin_peer 函数的执行流程如下所示：</p>

<ul>
<li>计算服务器列表中的数量 n，n 的取值为 非备用后端服务器数量 与 备用后端服务器数量 较大者；</li>
<li>根据 n 的取值，创建一个位图 tried，该位图是记录后端服务器是否被选择过： <br>
<ul><li>若 n 不大于 32， 只需要在一个 int 中记录所有后端服务器的状态；</li>
<li>若 n 大于 32，则需要从内存池申请内存来存储所有后端服务器的状态；</li></ul></li>
<li>设置 ngx_peer_connection_t 结构体中 get 的回调方法为  ngx_http_upstream_get_round_robin_peer；free 的回调方法为 ngx_http_upstream_free_round_robin_peer，设置  tries 重试连接的次数为非备用后端服务器的个数；</li>
</ul>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">/* 当客户端发起请求时，upstream 机制为本轮选择一个后端服务器做初始化工作 */</span>
ngx_int_t
ngx_http_upstream_init_round_robin_peer(ngx_http_request_t <span class="hljs-subst">*</span>r,
    ngx_http_upstream_srv_conf_t <span class="hljs-subst">*</span>us)
{
    ngx_uint_t                         n;
    ngx_http_upstream_rr_peer_data_t  <span class="hljs-subst">*</span>rrp;

    <span class="hljs-comment">/* 注意：r-&gt;upstream-&gt;peer 是 ngx_peer_connection_t 结构体类型 */</span>

    <span class="hljs-comment">/* 获取当前客户端请求中的 ngx_http_upstream_rr_peer_data_t 结构体 */</span>
    rrp <span class="hljs-subst">=</span> r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span><span class="hljs-built_in">data</span>;

    <span class="hljs-keyword">if</span> (rrp <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>) {
        rrp <span class="hljs-subst">=</span> ngx_palloc(r<span class="hljs-subst">-&gt;</span>pool, sizeof(ngx_http_upstream_rr_peer_data_t));
        <span class="hljs-keyword">if</span> (rrp <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>) {
            <span class="hljs-keyword">return</span> NGX_ERROR;
        }

        r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span><span class="hljs-built_in">data</span> <span class="hljs-subst">=</span> rrp;
    }

    <span class="hljs-comment">/* 获取非备用后端服务器列表 */</span>
    rrp<span class="hljs-subst">-&gt;</span>peers <span class="hljs-subst">=</span> us<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span><span class="hljs-built_in">data</span>;
    rrp<span class="hljs-subst">-&gt;</span>current <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">/* 若采用遍历方式选择后端服务器时，作为起始节点编号 */</span>

    <span class="hljs-comment">/* 下面是取值 n，若存在备用后端服务器列表，则 n 的值为非备用后端服务器个数 与 备用后端服务器个数 之间的较大者 */</span>

    n <span class="hljs-subst">=</span> rrp<span class="hljs-subst">-&gt;</span>peers<span class="hljs-subst">-&gt;</span>number;

    <span class="hljs-keyword">if</span> (rrp<span class="hljs-subst">-&gt;</span>peers<span class="hljs-subst">-&gt;</span>next <span class="hljs-subst">&amp;&amp;</span> rrp<span class="hljs-subst">-&gt;</span>peers<span class="hljs-subst">-&gt;</span>next<span class="hljs-subst">-&gt;</span>number <span class="hljs-subst">&gt;</span> n) {
        n <span class="hljs-subst">=</span> rrp<span class="hljs-subst">-&gt;</span>peers<span class="hljs-subst">-&gt;</span>next<span class="hljs-subst">-&gt;</span>number;
    }

    <span class="hljs-comment">/* rrp-&gt;tried 是一个位图，在本轮选择中，该位图记录各个后端服务器是否被选择过 */</span>

    <span class="hljs-comment">/*
     * 如果后端服务器数量 n 不大于 32，则只需在一个 int 中即可记录下所有后端服务器状态；
     * 如果后端服务器数量 n 大于 32，则需在内存池中申请内存来存储所有后端服务器的状态；
     */</span>
    <span class="hljs-keyword">if</span> (n <span class="hljs-subst">&lt;=</span> <span class="hljs-number">8</span> <span class="hljs-subst">*</span> sizeof(uintptr_t)) {
        rrp<span class="hljs-subst">-&gt;</span>tried <span class="hljs-subst">=</span> <span class="hljs-subst">&amp;</span>rrp<span class="hljs-subst">-&gt;</span><span class="hljs-built_in">data</span>;
        rrp<span class="hljs-subst">-&gt;</span><span class="hljs-built_in">data</span> <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;

    } <span class="hljs-keyword">else</span> {
        n <span class="hljs-subst">=</span> (n <span class="hljs-subst">+</span> (<span class="hljs-number">8</span> <span class="hljs-subst">*</span> sizeof(uintptr_t) <span class="hljs-subst">-</span> <span class="hljs-number">1</span>)) <span class="hljs-subst">/</span> (<span class="hljs-number">8</span> <span class="hljs-subst">*</span> sizeof(uintptr_t));

        rrp<span class="hljs-subst">-&gt;</span>tried <span class="hljs-subst">=</span> ngx_pcalloc(r<span class="hljs-subst">-&gt;</span>pool, n <span class="hljs-subst">*</span> sizeof(uintptr_t));
        <span class="hljs-keyword">if</span> (rrp<span class="hljs-subst">-&gt;</span>tried <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>) {
            <span class="hljs-keyword">return</span> NGX_ERROR;
        }
    }

    <span class="hljs-comment">/*
     * 设置 ngx_peer_connection_t 结构体中 get 、free 的回调方法；
     * 设置 ngx_peer_connection_t 结构体中 tries 重试连接的次数为非备用后端服务器的个数；
     */</span>
    r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span>get <span class="hljs-subst">=</span> ngx_http_upstream_get_round_robin_peer;
    r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span>free <span class="hljs-subst">=</span> ngx_http_upstream_free_round_robin_peer;
    r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span>tries <span class="hljs-subst">=</span> rrp<span class="hljs-subst">-&gt;</span>peers<span class="hljs-subst">-&gt;</span>number;
<span class="hljs-variable">#if</span> (NGX_HTTP_SSL)
    r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span>set_session <span class="hljs-subst">=</span>
                               ngx_http_upstream_set_round_robin_peer_session;
    r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span>save_session <span class="hljs-subst">=</span>
                               ngx_http_upstream_save_round_robin_peer_session;
<span class="hljs-variable">#endif</span>

    <span class="hljs-keyword">return</span> NGX_OK;
}</code></pre>



<h5 id="根据权重选择后端服务器">根据权重选择后端服务器</h5>

<p>完成后端服务器的初始化工作之后，根据各个后端服务器的权重来选择权重最高的后端服务器处理客户端请求，由函数 ngx_http_upstream_get_round_robin_peer 实现。</p>

<p>ngx_http_upstream_get_round_robin_peer 函数的执行流程如下所示：</p>

<ul>
<li><em>步骤1</em>：检查 ngx_http_upstream_rr_peers_t 结构体中的 single 标志位： <br>
<ul><li>若 single 标志位为 1，表示只有一台非备用后端服务器： <br>
<ul><li>接着检查该非备用后端服务器的 down 标志位： <br>
<ul><li>若 down 标志位为 0，则选择该非备用后端服务器来处理请求；</li>
<li>若 down 标志位为 1, 该非备用后端服务器表示不参与策略选择，则跳至 goto failed 步骤从备用后端服务器列表中选择后端服务器来处理请求； </li></ul></li></ul></li>
<li>若 single 标志位为 0，则表示不止一台非备用后端服务器，则调用 ngx_http_upstream_get_peer 方法根据非备用后端服务器的权重来选择一台后端服务器处理请求，根据该方法的返回值 peer 进行判断： <br>
<ul><li>若该方法返回值 peer = NULL， 表示在非备用后端服务器列表中没有选中到合适的后端服务器来处理请求，则跳至 goto failed 从备用后端服务器列表中选择一台后端服务器来处理请求；</li>
<li>若该方法返回值 peer 不为 NULL，表示已经选中了合适的后端服务器来处理请求，设置该服务器重试连接次数 tries，并 return NGX_OK 从当前函数返回；</li></ul></li></ul></li>
<li><em>goto failed 步骤</em>：计算备用后端服务器在位图 tried 中的位置 n，并把他们在位图的记录都设置为 0，此时，把备用后端服务器列表作为参数调用 ngx_http_upstream_get_round_robin_peer 选择一台后端服务器来处理请求；</li>
</ul>



<pre class="prettyprint"><code class=" hljs haskell">/* 选择一个后端服务器来处理请求 */
<span class="hljs-title">ngx_int_t</span>
<span class="hljs-title">ngx_http_upstream_get_round_robin_peer</span>(ngx_peer_connection_t *pc, void *<span class="hljs-typedef"><span class="hljs-keyword">data</span>)</span>
{
    ngx_http_upstream_rr_peer_data_t  *rrp = <span class="hljs-typedef"><span class="hljs-keyword">data</span>;</span>

    ngx_int_t                      rc;
    ngx_uint_t                     i, n;
    ngx_http_upstream_rr_peer_t   *peer;
    ngx_http_upstream_rr_peers_t  *peers;

    ngx_log_debug1(<span class="hljs-type">NGX_LOG_DEBUG_HTTP</span>, pc-&gt;log, <span class="hljs-number">0</span>,
                   <span class="hljs-string">"get rr peer, try: %ui"</span>, pc-&gt;tries);

    /* ngx_lock_mutex(rrp-&gt;peers-&gt;mutex); */

    pc-&gt;cached = <span class="hljs-number">0</span>;
    pc-&gt;connection = <span class="hljs-type">NULL</span>;

    /*
     * 检查 ngx_http_upstream_rr_peers_t 结构体中的 single 标志位;
     * 若 single 标志位为 <span class="hljs-number">1</span>，表示只有一台非备用后端服务器，
     * 接着检查该非备用后端服务器的 down 标志位，若 down 标志位为 <span class="hljs-number">0</span>，则选择该非备用后端服务器来处理请求；
     * 若 down 标志位为 <span class="hljs-number">1</span>, 该非备用后端服务器表示不参与策略选择，
     * 则跳至 goto failed 步骤从备用后端服务器列表中选择后端服务器来处理请求；
     */
    <span class="hljs-keyword">if</span> (rrp-&gt;peers-&gt;single) {
        peer = &amp;rrp-&gt;peers-&gt;peer[<span class="hljs-number">0</span>];

        <span class="hljs-keyword">if</span> (peer-&gt;down) {
            goto failed;
        }

    } <span class="hljs-keyword">else</span> {/* 若 single 标志位为 <span class="hljs-number">0</span>，表示不止一台非备用后端服务器 */

        /* there are several peers */

        /* 根据非备用后端服务器的权重来选择一台后端服务器处理请求 */
        peer = ngx_http_upstream_get_peer(rrp);

        <span class="hljs-keyword">if</span> (peer == <span class="hljs-type">NULL</span>) {
            /*
             * 若从非备用后端服务器列表中没有选择一台合适的后端服务器处理请求，
             * 则 goto failed 从备用后端服务器列表中选择一台后端服务器来处理请求；
             */
            goto failed;
        }

        ngx_log_debug2(<span class="hljs-type">NGX_LOG_DEBUG_HTTP</span>, pc-&gt;log, <span class="hljs-number">0</span>,
                       <span class="hljs-string">"get rr peer, current: %ui %i"</span>,
                       rrp-&gt;current, peer-&gt;current_weight);
    }

    /*
     * 若从非备用后端服务器列表中已经选到了一台合适的后端服务器处理请求;
     * 则获取该后端服务器的地址信息；
     */
    pc-&gt;sockaddr = peer-&gt;sockaddr;/* 获取被选中的非备用后端服务器的地址 */
    pc-&gt;socklen = peer-&gt;socklen;/* 获取被选中的非备用后端服务器的地址长度 */
    pc-&gt;name = &amp;peer-&gt;name;/* 获取被选中的非备用后端服务器的域名 */

    /* ngx_unlock_mutex(rrp-&gt;peers-&gt;mutex); */

    /*
     * 检查被选中的非备用后端服务器重试连接的次数为 <span class="hljs-number">1</span>，且存在备用后端服务器列表，
     * 则将该非备用后端服务器重试连接的次数设置为 备用后端服务器个数加 <span class="hljs-number">1</span>；
     * 否则不用重新设置；
     */
    <span class="hljs-keyword">if</span> (pc-&gt;tries == <span class="hljs-number">1</span> &amp;&amp; rrp-&gt;peers-&gt;next) {
        pc-&gt;tries += rrp-&gt;peers-&gt;next-&gt;number;
    }

    /* 到此，表示已经选择到了一台合适的非备用后端服务器来处理请求，则成功返回 */
    return <span class="hljs-type">NGX_OK</span>;

<span class="hljs-title">failed</span>:
      /*
       * 若从非备用后端服务器列表中没有选择到后端服务器处理请求，
       * 若存在备用后端服务器，则从备用后端服务器列表中选择一台后端服务器来处理请求；
       */

    peers = rrp-&gt;peers;

    /* 若存在备用后端服务器，则从备用后端服务器列表中选择一台后端服务器来处理请求；*/
    <span class="hljs-keyword">if</span> (peers-&gt;next) {

        /* ngx_unlock_mutex(peers-&gt;mutex); */

        ngx_log_debug0(<span class="hljs-type">NGX_LOG_DEBUG_HTTP</span>, pc-&gt;log, <span class="hljs-number">0</span>, <span class="hljs-string">"backup servers"</span>);

        /* 获取备用后端服务器列表 */
        rrp-&gt;peers = peers-&gt;next;
        /* 把后端服务器重试连接的次数 tries 设置为备用后端服务器个数 number */
        pc-&gt;tries = rrp-&gt;peers-&gt;number;

        /* 计算备用后端服务器在位图中的位置 n */
        n = (rrp-&gt;peers-&gt;number + (<span class="hljs-number">8</span> * sizeof(uintptr_t) - <span class="hljs-number">1</span>))
                / (<span class="hljs-number">8</span> * sizeof(uintptr_t));

        /* 初始化备用后端服务器在位图 rrp-&gt;tried[i] 中的值为 <span class="hljs-number">0</span> */
        for (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
             rrp-&gt;tried[i] = <span class="hljs-number">0</span>;
        }

        /* 把备用后端服务器列表当前非备用后端服务器列表递归调用 ngx_http_upstream_get_round_robin_peer 选择一台后端服务器 */
        rc = ngx_http_upstream_get_round_robin_peer(pc, rrp);

        /* 若选择成功则返回 */
        <span class="hljs-keyword">if</span> (rc != <span class="hljs-type">NGX_BUSY</span>) {
            return rc;
        }

        /* ngx_lock_mutex(peers-&gt;mutex); */
    }

    /*
     * 若从备用后端服务器列表中也没有选择到一台后端服务器处理请求，
     * 则重新设置非备用后端服务器连接失败的次数 fails 为 <span class="hljs-number">0</span> ,以便重新被选择；
     */
    /* all peers failed, mark them <span class="hljs-keyword">as</span> live for quick recovery */

    for (i = <span class="hljs-number">0</span>; i &lt; peers-&gt;number; i++) {
        peers-&gt;peer[i].fails = <span class="hljs-number">0</span>;
    }

    /* ngx_unlock_mutex(peers-&gt;mutex); */

    pc-&gt;name = peers-&gt;name;

    /* 选择失败，则返回 */
    return <span class="hljs-type">NGX_BUSY</span>;
}</code></pre>

<p>ngx_http_upstream_get_peer 函数是计算每一个后端服务器的权重值，并选择一个权重最高的后端服务器。</p>

<p>ngx_http_upstream_get_peer 函数的执行流程如下所示：</p>

<ul>
<li>for 循环遍历后端服务器列表，计算当前后端服务器在位图 tried 中的位置 n，判断当前服务器是否在位图中记录过，若已经记录过，则 continue 继续检查下一个后端服务器；若没有记录过则继续当前后端服务器检查；</li>
<li>检查当前后端服务器的标志位 down，若该标志位为 1，表示该后端服务器不参与选择策略，则 continue 继续检查下一个后端服务器；若该标志位为 0，继续当前后端服务器的检查；</li>
<li>若当前后端服务器的连接失败次数已到达 max_failes，且睡眠时间还没到 fail_timedout ，则 continue 继续检查下一个后端服务器；否则继续当前后端服务器的检查；</li>
<li>计算当前后端服务器的权重，设置当前后端服务器的权重 current_weight 的值为原始值加上 effective_weight；设置总的权重 total 为原始值加上 effective_weight；</li>
<li>判断当前后端服务器是否异常，若 effective_weight 小于 weight，表示正常，则调整 effective_weight 的值  effective_weight++；</li>
<li>根据权重在后端服务器列表中选择权重最高的后端服务器 best；</li>
<li>计算被选中后端服务器咋服务器列表中的为 i，记录被选中后端服务器在 ngx_http_upstream_rr_peer_data_t 结构体 current 成员的值，在释放后端服务器时会用到该值；</li>
<li>计算被选中后端服务器在位图中的位置 n，并在该位置记录 best 后端服务器已经被选中过；</li>
<li>更新被选中后端服务器的权重，并返回被选中的后端服务器 best；</li>
</ul>



<pre class="prettyprint"><code class=" hljs objectivec"> <span class="hljs-comment">/* 根据后端服务器的权重来选择一台后端服务器处理请求 */</span>
<span class="hljs-keyword">static</span> ngx_http_upstream_rr_peer_t *
ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp)
{
    time_t                        now;
    uintptr_t                     m;
    ngx_int_t                     total;
    ngx_uint_t                    i, n;
    ngx_http_upstream_rr_peer_t  *peer, *best;

    now = ngx_time();

    best = <span class="hljs-literal">NULL</span>;
    total = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* 遍历后端服务器列表 */</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; rrp-&gt;peers-&gt;number; i++) {

        <span class="hljs-comment">/* 计算当前后端服务器在位图中的位置 n */</span>
        n = i / (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(uintptr_t));
        m = (uintptr_t) <span class="hljs-number">1</span> &lt;&lt; i % (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(uintptr_t));

        <span class="hljs-comment">/* 当前后端服务器在位图中已经有记录，则不再次被选择，即 continue 检查下一个后端服务器 */</span>
        <span class="hljs-keyword">if</span> (rrp-&gt;tried[n] &amp; m) {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-comment">/* 若当前后端服务器在位图中没有记录，则可能被选中，接着计算其权重 */</span>
        peer = &amp;rrp-&gt;peers-&gt;peer[i];

        <span class="hljs-comment">/* 检查当前后端服务器的 down 标志位，若为 1 表示不参与策略选择，则 continue 检查下一个后端服务器 */</span>
        <span class="hljs-keyword">if</span> (peer-&gt;down) {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-comment">/*
         * 当前后端服务器的 down 标志位为 0,接着检查当前后端服务器连接失败的次数是否已经达到 max_fails；
         * 且睡眠的时间还没到 fail_timeout，则当前后端服务器不被选择，continue 检查下一个后端服务器；
         */</span>
        <span class="hljs-keyword">if</span> (peer-&gt;max_fails
            &amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails
            &amp;&amp; now - peer-&gt;checked &lt;= peer-&gt;fail_timeout)
        {
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-comment">/* 若当前后端服务器可能被选中，则计算其权重 */</span>

        <span class="hljs-comment">/*
         * 在上面初始化过程中 current_weight = 0，effective_weight = weight；
         * 此时，设置当前后端服务器的权重 current_weight 的值为原始值加上 effective_weight；
         * 设置总的权重为原始值加上 effective_weight；
         */</span>
        peer-&gt;current_weight += peer-&gt;effective_weight;
        total += peer-&gt;effective_weight;

        <span class="hljs-comment">/* 服务器正常，调整 effective_weight 的值 */</span>
        <span class="hljs-keyword">if</span> (peer-&gt;effective_weight &lt; peer-&gt;weight) {
            peer-&gt;effective_weight++;
        }

        <span class="hljs-comment">/* 若当前后端服务器的权重 current_weight 大于目前 best 服务器的权重，则当前后端服务器被选中 */</span>
        <span class="hljs-keyword">if</span> (best == <span class="hljs-literal">NULL</span> || peer-&gt;current_weight &gt; best-&gt;current_weight) {
            best = peer;
        }
    }

    <span class="hljs-keyword">if</span> (best == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }

    <span class="hljs-comment">/* 计算被选中后端服务器在服务器列表中的位置 i */</span>
    i = best - &amp;rrp-&gt;peers-&gt;peer[<span class="hljs-number">0</span>];

    <span class="hljs-comment">/* 记录被选中后端服务器在 ngx_http_upstream_rr_peer_data_t 结构体 current 成员的值，在释放后端服务器时会用到该值 */</span>
    rrp-&gt;current = i;

    <span class="hljs-comment">/* 计算被选中后端服务器在位图中的位置 */</span>
    n = i / (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(uintptr_t));
    m = (uintptr_t) <span class="hljs-number">1</span> &lt;&lt; i % (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(uintptr_t));

    <span class="hljs-comment">/* 在位图相应的位置记录被选中后端服务器 */</span>
    rrp-&gt;tried[n] |= m;

    <span class="hljs-comment">/* 更新被选中后端服务器的权重 */</span>
    best-&gt;current_weight -= total;

    <span class="hljs-keyword">if</span> (now - best-&gt;checked &gt; best-&gt;fail_timeout) {
        best-&gt;checked = now;
    }

    <span class="hljs-comment">/* 返回被选中的后端服务器 */</span>
    <span class="hljs-keyword">return</span> best;
}</code></pre>



<h4 id="释放后端服务器">释放后端服务器</h4>

<p>成功连接后端服务器并且正常处理完成客户端请求后需释放后端服务器，由函数 ngx_http_upstream_free_round_robin_peer 实现。</p>



<pre class="prettyprint"><code class=" hljs haskell">/* 释放后端服务器 */
<span class="hljs-title">void</span>
<span class="hljs-title">ngx_http_upstream_free_round_robin_peer</span>(ngx_peer_connection_t *pc, void *<span class="hljs-typedef"><span class="hljs-keyword">data</span>,</span>
    ngx_uint_t state)
{
    ngx_http_upstream_rr_peer_data_t  *rrp = <span class="hljs-typedef"><span class="hljs-keyword">data</span>;</span>

    time_t                       now;
    ngx_http_upstream_rr_peer_t  *peer;

    ngx_log_debug2(<span class="hljs-type">NGX_LOG_DEBUG_HTTP</span>, pc-&gt;log, <span class="hljs-number">0</span>,
                   <span class="hljs-string">"free rr peer %ui %ui"</span>, pc-&gt;tries, state);

    /* <span class="hljs-type">TODO</span>: <span class="hljs-type">NGX_PEER_KEEPALIVE</span> */

    /* 若只有一个后端服务器，则设置 ngx_peer_connection_t 结构体成员 tries 为 <span class="hljs-number">0</span>，并 return 返回 */
    <span class="hljs-keyword">if</span> (rrp-&gt;peers-&gt;single) {
        pc-&gt;tries = <span class="hljs-number">0</span>;
        return;
    }

    /* 若不止一个后端服务器，则执行以下程序 */

    /* 获取已经被选中的后端服务器 */
    peer = &amp;rrp-&gt;peers-&gt;peer[rrp-&gt;current];

    /*
     * 若在本轮被选中的后端服务器在进行连接测试时失败，或者在处理请求过程中失败，
     * 则需要进行重新选择后端服务器；
     */
    <span class="hljs-keyword">if</span> (state &amp; <span class="hljs-type">NGX_PEER_FAILED</span>) {
        now = ngx_time();

        /* ngx_lock_mutex(rrp-&gt;peers-&gt;mutex); */

        peer-&gt;fails++;/* 增加当前后端服务器失败的次数 */
        /* 设置当前后端服务器访问的时间 */
        peer-&gt;accessed = now;
        peer-&gt;checked = now;

        <span class="hljs-keyword">if</span> (peer-&gt;max_fails) {
            /* 由于当前后端服务器失败，表示发生异常，此时降低 effective_weight 的值 */
            peer-&gt;effective_weight -= peer-&gt;weight / peer-&gt;max_fails;
        }

        ngx_log_debug2(<span class="hljs-type">NGX_LOG_DEBUG_HTTP</span>, pc-&gt;log, <span class="hljs-number">0</span>,
                       <span class="hljs-string">"free rr peer failed: %ui %i"</span>,
                       rrp-&gt;current, peer-&gt;effective_weight);

        /* 保证 effective_weight 的值不能小于 <span class="hljs-number">0</span> */
        <span class="hljs-keyword">if</span> (peer-&gt;effective_weight &lt; <span class="hljs-number">0</span>) {
            peer-&gt;effective_weight = <span class="hljs-number">0</span>;
        }

        /* ngx_unlock_mutex(rrp-&gt;peers-&gt;mutex); */

    } <span class="hljs-keyword">else</span> {/* 若被选中的后端服务器成功处理请求，并返回，则将其 fails 设置为 <span class="hljs-number">0</span> */

        /* mark peer live <span class="hljs-keyword">if</span> check passed */

        /* 若 fail_timeout 时间已过，则将其 fails 设置为 <span class="hljs-number">0</span> */
        <span class="hljs-keyword">if</span> (peer-&gt;accessed &lt; peer-&gt;checked) {
            peer-&gt;fails = <span class="hljs-number">0</span>;
        }
    }

    /* 减少 tries 的值 */
    <span class="hljs-keyword">if</span> (pc-&gt;tries) {
        pc-&gt;tries<span class="hljs-comment">--;</span>
    }

    /* ngx_unlock_mutex(rrp-&gt;peers-&gt;mutex); */
}</code></pre>



<h2 id="ip-哈希">IP 哈希</h2>

<p>IP 哈希策略选择后端服务器时，将来自同一个 IP 地址的客户端请求分发到同一台后端服务器处理。在 Nginx 中，IP 哈希策略的一些初始化工作是基于加权轮询策略的，这样减少了一些工作。</p>

<p>Nginx 使用 IP 哈希负载均衡策略时，在进行策略选择之前由 ngx_http_upstream_init_ip_hash 函数进行全局初始化工作，其实该函数也是调用加权轮询策略的全局初始化函数。当一个客户端请求过来时，Nginx 将调用 ngx_http_upstream_init_ip_hash_peer() 为选择后端服务器处理该请求做初始化工作。在多次哈希选择失败后，Nginx 会将选择策略退化到加权轮询。</p>

<p>ngx_http_upstream_get_ip_hash_peer 函数会在选择后端服务器时计算客户端请求 IP 地址的哈希值，并根据哈希值得到被选中的后端服务器，判断其是否可用，如果可用则保存服务器地址，若不可用则在上次哈希选择结果基础上再次进行哈希选择。如果哈希选择失败次数达到 20 次以上，此时回退到采用轮询策略进行选择。</p>



<h3 id="初始化后端服务器列表">初始化后端服务器列表</h3>

<p>初始化服务器列表工作是调用加权轮询策略的初始化函数，只是最后设置 IP 哈希的回调方法为 ngx_http_upstream_init_ip_hash_peer。</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">static</span> ngx_int_t
ngx_http_upstream_init_ip_hash(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
{
    <span class="hljs-comment">/* 调用加权轮询策略的初始化函数 */</span>
    <span class="hljs-keyword">if</span> (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
        <span class="hljs-keyword">return</span> NGX_ERROR;
    }

    <span class="hljs-comment">/* 由于 ngx_http_upstream_init_round_robin 方法的选择后端服务器处理客户请求的初始化函数
     * 为 us-&gt;peer.init = ngx_http_upstream_init_round_robin_peer;
     */</span>
    <span class="hljs-comment">/* 重新设置 ngx_http_upstream_peer_t 结构体中 init 的回调方法为  ngx_http_upstream_init_ip_hash_peer */</span>

    us-&gt;peer.init = ngx_http_upstream_init_ip_hash_peer;

    <span class="hljs-keyword">return</span> NGX_OK;
}</code></pre>



<h3 id="选择后端服务器">选择后端服务器</h3>

<p>选择后端服务器之前会调用函数 ngx_http_upstream_init_ip_hash_peer 进行一些服务器初始化工作。最终由函数 ngx_http_upstream_get_ip_hash_peer 进行 IP 哈希选择。</p>

<p>ngx_http_upstream_init_ip_hash_peer 函数执行流程：</p>

<ul>
<li>调用加权轮询策略的初始化函数 ngx_http_upstream_init_round_robin_peer；</li>
<li>设置 IP hash 的决策函数为 ngx_http_upstream_get_ip_hash_peer；</li>
<li>保存客户端 IP 地址；</li>
<li>初始化 ngx_http_upstream_ip_hash_peer_data_t结构体成员 hash 值为 89；tries 重试连接次数为 0；get_rr_peer 为加权轮询的决策函数 ngx_http_upstream_get_round_robin_peer；</li>
</ul>

<p>ngx_http_upstream_get_ip_hash_peer 函数执行流程：</p>

<ul>
<li>若重试连接的次数 tries 大于 20，或 只有一台后端服务器，则直接调用加权轮询策略 get_rr_peer 选择当前后端服务器处理请求；</li>
<li>计算 IP 地址的 hash 值，下面根据哈希值进行选择后端服务器；</li>
<li>若 ngx_http_upstream_rr_peers_t 结构体中 weighted 标志位为 1，则被选中的后端服务器在后端服务器列表中的位置为 hash 值与后端服务器数量的余数 p；</li>
<li>若 ngx_http_upstream_rr_peers_t 结构体中 weighted 标志位为 0，首先计算 hash 值与后端服务器总权重的余数 w； 将 w 值减去后端服务器的权重，直到有一个后端服务器使 w 值小于 0，则选中该后端服务器来处理请求，并记录在后端服务器列表中的位置 p；</li>
<li>计算被选中后端服务器在位图中的位置 n；</li>
<li>若当前被选中的后端服务器已经在位图记录过，则跳至 goto next 执行；</li>
<li>检查当前被选中后端服务器的 down 标志位： <br>
<ul><li>若该标志位为1，则跳至 goto next_try 执行；</li>
<li>若 down 标志位为 0，接着检查当前被选中后端服务器失败连接次数是否到达 max_fails，若已经达到 max_fails 次，并且睡眠时间还没到 fail_timeout，则跳至 goto next_try 执行；</li></ul></li>
<li>若不满足以上条件，表示选择成功，记录当前后端服务器的地址信息，把当前后端服务器记录在位图相应的位置，更新哈希值，最后返回该后端服务器；</li>
<li><em>goto next</em>：tries 重试连接的次数加 1，并判断 tries 是否大于阈值 20，若大于，则采用加权轮询策略；</li>
<li><em>goto next_try </em>：把当前后端服务器记录在位图中，减少当前后端服务器重试连接的次数 tries；</li>
</ul>

<pre class="prettyprint"><code class=" hljs lasso">static ngx_int_t
ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t <span class="hljs-subst">*</span>r,
    ngx_http_upstream_srv_conf_t <span class="hljs-subst">*</span>us)
{
    struct sockaddr_in                     <span class="hljs-subst">*</span>sin;
<span class="hljs-variable">#if</span> (NGX_HAVE_INET6)
    struct sockaddr_in6                    <span class="hljs-subst">*</span>sin6;
<span class="hljs-variable">#endif</span>
    ngx_http_upstream_ip_hash_peer_data_t  <span class="hljs-subst">*</span>iphp;

    <span class="hljs-comment">/* 分配 ngx_http_upstream_ip_hash_peer_data_t 结构体内存空间 */</span>
    iphp <span class="hljs-subst">=</span> ngx_palloc(r<span class="hljs-subst">-&gt;</span>pool, sizeof(ngx_http_upstream_ip_hash_peer_data_t));
    <span class="hljs-keyword">if</span> (iphp <span class="hljs-subst">==</span> <span class="hljs-built_in">NULL</span>) {
        <span class="hljs-keyword">return</span> NGX_ERROR;
    }

    r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span><span class="hljs-built_in">data</span> <span class="hljs-subst">=</span> <span class="hljs-subst">&amp;</span>iphp<span class="hljs-subst">-&gt;</span>rrp;

    <span class="hljs-comment">/* 调用加权轮询策略的初始化函数 ngx_http_upstream_init_round_robin_peer */</span>
    <span class="hljs-keyword">if</span> (ngx_http_upstream_init_round_robin_peer(r, us) <span class="hljs-subst">!=</span> NGX_OK) {
        <span class="hljs-keyword">return</span> NGX_ERROR;
    }

    <span class="hljs-comment">/* 设置 IP hash 的决策函数  */</span>
    r<span class="hljs-subst">-&gt;</span>upstream<span class="hljs-subst">-&gt;</span>peer<span class="hljs-built_in">.</span>get <span class="hljs-subst">=</span> ngx_http_upstream_get_ip_hash_peer;

    switch (r<span class="hljs-subst">-&gt;</span>connection<span class="hljs-subst">-&gt;</span>sockaddr<span class="hljs-subst">-&gt;</span>sa_family) {

    <span class="hljs-comment">/* 保存客户端 IP 地址 */</span>

    <span class="hljs-comment">/* IPv4 地址 */</span>
    <span class="hljs-keyword">case</span> AF_INET:
        sin <span class="hljs-subst">=</span> (struct sockaddr_in <span class="hljs-subst">*</span>) r<span class="hljs-subst">-&gt;</span>connection<span class="hljs-subst">-&gt;</span>sockaddr;
        iphp<span class="hljs-subst">-&gt;</span>addr <span class="hljs-subst">=</span> (u_char <span class="hljs-subst">*</span>) <span class="hljs-subst">&amp;</span>sin<span class="hljs-subst">-&gt;</span>sin_addr<span class="hljs-built_in">.</span>s_addr;
        iphp<span class="hljs-subst">-&gt;</span>addrlen <span class="hljs-subst">=</span> <span class="hljs-number">3</span>;
        break;

    <span class="hljs-comment">/* IPv6 地址 */</span>
<span class="hljs-variable">#if</span> (NGX_HAVE_INET6)
    <span class="hljs-keyword">case</span> AF_INET6:
        sin6 <span class="hljs-subst">=</span> (struct sockaddr_in6 <span class="hljs-subst">*</span>) r<span class="hljs-subst">-&gt;</span>connection<span class="hljs-subst">-&gt;</span>sockaddr;
        iphp<span class="hljs-subst">-&gt;</span>addr <span class="hljs-subst">=</span> (u_char <span class="hljs-subst">*</span>) <span class="hljs-subst">&amp;</span>sin6<span class="hljs-subst">-&gt;</span>sin6_addr<span class="hljs-built_in">.</span>s6_addr;
        iphp<span class="hljs-subst">-&gt;</span>addrlen <span class="hljs-subst">=</span> <span class="hljs-number">16</span>;
        break;
<span class="hljs-variable">#endif</span>

    <span class="hljs-comment">/* 非法地址 */</span>
    default:
        iphp<span class="hljs-subst">-&gt;</span>addr <span class="hljs-subst">=</span> ngx_http_upstream_ip_hash_pseudo_addr;
        iphp<span class="hljs-subst">-&gt;</span>addrlen <span class="hljs-subst">=</span> <span class="hljs-number">3</span>;
    }

    <span class="hljs-comment">/* 初始化 ngx_http_upstream_ip_hash_peer_data_t结构体成员 */</span>
    iphp<span class="hljs-subst">-&gt;</span>hash <span class="hljs-subst">=</span> <span class="hljs-number">89</span>;
    iphp<span class="hljs-subst">-&gt;</span>tries <span class="hljs-subst">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">/* 这个是设置为加权轮询策略的决策函数 */</span>
    iphp<span class="hljs-subst">-&gt;</span>get_rr_peer <span class="hljs-subst">=</span> ngx_http_upstream_get_round_robin_peer;

    <span class="hljs-keyword">return</span> NGX_OK;
}</code></pre>



<pre class="prettyprint"><code class=" hljs haskell">/* 选择后端服务器处理请求 */
<span class="hljs-title">static</span> ngx_int_t
<span class="hljs-title">ngx_http_upstream_get_ip_hash_peer</span>(ngx_peer_connection_t *pc, void *<span class="hljs-typedef"><span class="hljs-keyword">data</span>)</span>
{
    ngx_http_upstream_ip_hash_peer_data_t  *iphp = <span class="hljs-typedef"><span class="hljs-keyword">data</span>;</span>

    time_t                        now;
    ngx_int_t                     w;
    uintptr_t                     m;
    ngx_uint_t                    i, n, p, hash;
    ngx_http_upstream_rr_peer_t  *peer;

    ngx_log_debug1(<span class="hljs-type">NGX_LOG_DEBUG_HTTP</span>, pc-&gt;log, <span class="hljs-number">0</span>,
                   <span class="hljs-string">"get ip hash peer, try: %ui"</span>, pc-&gt;tries);

    /* <span class="hljs-type">TODO</span>: cached */

    /* 若重试连接的次数 tries 大于 <span class="hljs-number">20</span>，或 只有一台后端服务器，则直接调用加权轮询策略选择当前后端服务器处理请求 */
    <span class="hljs-keyword">if</span> (iphp-&gt;tries &gt; <span class="hljs-number">20</span> || iphp-&gt;rrp.peers-&gt;single) {
        return iphp-&gt;get_rr_peer(pc, &amp;iphp-&gt;rrp);
    }

    now = ngx_time();

    pc-&gt;cached = <span class="hljs-number">0</span>;
    pc-&gt;connection = <span class="hljs-type">NULL</span>;

    hash = iphp-&gt;hash;

    for ( ;; ) {

        /* 计算 <span class="hljs-type">IP</span> 地址的 hash 值 */
        for (i = <span class="hljs-number">0</span>; i &lt; (ngx_uint_t) iphp-&gt;addrlen; i++) {
            hash = (hash * <span class="hljs-number">113</span> + iphp-&gt;addr[i]) % <span class="hljs-number">6271</span>;/* hash 函数 */
        }

        /* 以下是根据 hash 值选择合适的后端服务器来处理请求 */

        /* 若 ngx_http_upstream_rr_peers_t 结构体中 weighted 标志位为 <span class="hljs-number">1</span>，
         * 表示所有后端服务器的总权重 与 后端服务器的数量 相等，
         * 则被选中的后端服务器在后端服务器列表中的位置为 hash 值与后端服务器数量的余数 p；
         */
        <span class="hljs-keyword">if</span> (!iphp-&gt;rrp.peers-&gt;weighted) {
            p = hash % iphp-&gt;rrp.peers-&gt;number;

        } <span class="hljs-keyword">else</span> {
            /* 若 ngx_http_upstream_rr_peers_t 结构体中 weighted 标志位为 <span class="hljs-number">0</span>，
             * 首先计算 hash 值与后端服务器总权重的余数 w；
             * 将 w 值减去后端服务器的权重，直到有一个后端服务器使 w 值小于 <span class="hljs-number">0</span>，
             * 则选中该后端服务器来处理请求，并记录在后端服务器列表中的位置 p；
             */
            w = hash % iphp-&gt;rrp.peers-&gt;total_weight;

            for (i = <span class="hljs-number">0</span>; i &lt; iphp-&gt;rrp.peers-&gt;number; i++) {
                w -= iphp-&gt;rrp.peers-&gt;peer[i].weight;
                <span class="hljs-keyword">if</span> (w &lt; <span class="hljs-number">0</span>) {
                    break;
                }
            }

            p = i;
        }

        /* 计算被选中后端服务器在位图中的位置 n */
        n = p / (<span class="hljs-number">8</span> * sizeof(uintptr_t));
        m = (uintptr_t) <span class="hljs-number">1</span> &lt;&lt; p % (<span class="hljs-number">8</span> * sizeof(uintptr_t));

        /* 若当前被选中的后端服务器已经在位图记录过，则跳至 goto next 执行 */
        <span class="hljs-keyword">if</span> (iphp-&gt;rrp.tried[n] &amp; m) {
            goto next;
        }

        ngx_log_debug2(<span class="hljs-type">NGX_LOG_DEBUG_HTTP</span>, pc-&gt;log, <span class="hljs-number">0</span>,
                       <span class="hljs-string">"get ip hash peer, hash: %ui %04XA"</span>, p, m);

        /* 获取当前被选中的后端服务器 */
        peer = &amp;iphp-&gt;rrp.peers-&gt;peer[p];

        /* ngx_lock_mutex(iphp-&gt;rrp.peers-&gt;mutex); */

        /* 检查当前被选中后端服务器的 down 标志位，若该标志位为<span class="hljs-number">1</span>，则跳至 goto next_try 执行 */
        <span class="hljs-keyword">if</span> (peer-&gt;down) {
            goto next_try;
        }

        /* 若 down 标志位为 <span class="hljs-number">0</span>，接着检查当前被选中后端服务器失败连接次数是否到达 max_fails，
         * 若已经达到 max_fails 次，并且睡眠时间还没到 fail_timeout，则跳至 goto next_try 执行；
         */
        <span class="hljs-keyword">if</span> (peer-&gt;max_fails
            &amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails
            &amp;&amp; now - peer-&gt;checked &lt;= peer-&gt;fail_timeout)
        {
            goto next_try;
        }

        /* 若不满足以上条件，则表示选择后方服务器成功 */
        break;

    next_try:

        /* 把当前后端服务器记录在位图中 */
        iphp-&gt;rrp.tried[n] |= m;

        /* ngx_unlock_mutex(iphp-&gt;rrp.peers-&gt;mutex); */

        /* 减少当前后端服务器重试连接的次数 */
        pc-&gt;tries<span class="hljs-comment">--;</span>

    next:

        /* tries 重试连接的次数加 <span class="hljs-number">1</span>，并判断 tries 是否大于阈值 <span class="hljs-number">20</span>，若大于，则采用加权轮询策略 */
        <span class="hljs-keyword">if</span> (++iphp-&gt;tries &gt;= <span class="hljs-number">20</span>) {
            return iphp-&gt;get_rr_peer(pc, &amp;iphp-&gt;rrp);
        }
    }

    /* 到此已经成功选择了后端服务器来处理请求 */

    /* 记录当前后端服务器在后端服务器列表中的位置，该位置方便释放后端服务器调用 */
    iphp-&gt;rrp.current = p;

    /* 记录当前后端服务器的地址信息 */
    pc-&gt;sockaddr = peer-&gt;sockaddr;
    pc-&gt;socklen = peer-&gt;socklen;
    pc-&gt;name = &amp;peer-&gt;name;

    <span class="hljs-keyword">if</span> (now - peer-&gt;checked &gt; peer-&gt;fail_timeout) {
        peer-&gt;checked = now;
    }

    /* ngx_unlock_mutex(iphp-&gt;rrp.peers-&gt;mutex); */

    /* 把当前后端服务器记录在位图相应的位置 */
    iphp-&gt;rrp.tried[n] |= m;
    /* 记录 hash 值 */
    iphp-&gt;hash = hash;

    return <span class="hljs-type">NGX_OK</span>;
}</code></pre>

<h2 id="总结">总结</h2>

<p><strong>加权轮询策略</strong>：不依赖于客户端的任何信息，完全依靠后端服务器的情况来进行选择。但是同一个客户端的多次请求可能会被分配到不同的后端服务器进行处理，无法满足做会话保持的应用的需求。</p>

<p><strong>IP哈希策略</strong>：把同一个 IP 地址的客户端请求分配到同一台服务器处理，避免了加权轮询无法适用会话保持的需求。但是来自同一的 IP 地址的请求比较多时，会导致某台后端服务器的压力可能非常大，而其他后端服务器却空闲的不均衡情况。</p></div></body>
</html>